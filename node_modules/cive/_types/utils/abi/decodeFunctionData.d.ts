import type { Abi, AbiStateMutability } from '../../types/abitype.js';
import type { ErrorType } from '../../errors/utils.js';
import type { ContractFunctionArgs, ContractFunctionName } from '../../types/contract.js';
import type { Hex } from '../../types/misc.js';
import type { IsNarrowable, UnionEvaluate } from '../../types/utils.js';
import { AbiFunctionSignatureNotFoundError, type SliceErrorType, type ToFunctionSelectorErrorType } from 'viem';
import { type FormatAbiItemErrorType } from 'viem/utils';
import { type DecodeAbiParametersErrorType } from './decodeAbiParameters.js';
export type DecodeFunctionDataParameters<abi extends Abi | readonly unknown[] = Abi> = {
    abi: abi;
    data: Hex;
} & {
    /**
     * need update. this should be only pass by decode address type
     */
    networkId: number;
};
export type DecodeFunctionDataReturnType<abi extends Abi | readonly unknown[] = Abi, allFunctionNames extends ContractFunctionName<abi> = ContractFunctionName<abi>> = IsNarrowable<abi, Abi> extends true ? UnionEvaluate<{
    [functionName in allFunctionNames]: {
        args: ContractFunctionArgs<abi, AbiStateMutability, functionName>;
        functionName: functionName;
    };
}[allFunctionNames]> : {
    args: readonly unknown[] | undefined;
    functionName: string;
};
export type DecodeFunctionDataErrorType = AbiFunctionSignatureNotFoundError | DecodeAbiParametersErrorType | FormatAbiItemErrorType | ToFunctionSelectorErrorType | SliceErrorType | ErrorType;
export declare function decodeFunctionData<const abi extends Abi | readonly unknown[]>(parameters: DecodeFunctionDataParameters<abi>): DecodeFunctionDataReturnType<abi>;
//# sourceMappingURL=decodeFunctionData.d.ts.map