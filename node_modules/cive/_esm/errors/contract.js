import { parseAccount } from '../accounts/utils/parseAccount.js';
import { AbiErrorSignatureNotFoundError, BaseError, decodeErrorResult, getAbiItem, } from 'viem';
import { formatAbiItem, formatAbiItemWithArgs } from 'viem/utils';
import { panicReasons } from '../constants/solidity.js';
import { formatCFX } from '../utils/unit/formatCFX.js';
import { formatGDrip } from '../utils/unit/formatGDrip.js';
import { prettyPrint } from './transaction.js';
export class CallExecutionError extends BaseError {
    cause;
    name = 'CallExecutionError';
    constructor(cause, { account: account_, docsPath, chain, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, }) {
        const account = account_ ? parseAccount(account_) : undefined;
        const prettyArgs = prettyPrint({
            from: account?.address,
            to,
            value: typeof value !== 'undefined' &&
                `${formatCFX(value)} ${chain?.nativeCurrency?.symbol || 'CFX'}`,
            data,
            gas,
            gasPrice: typeof gasPrice !== 'undefined' && `${formatGDrip(gasPrice)} gdrip`,
            maxFeePerGas: typeof maxFeePerGas !== 'undefined' &&
                `${formatGDrip(maxFeePerGas)} gdrip`,
            maxPriorityFeePerGas: typeof maxPriorityFeePerGas !== 'undefined' &&
                `${formatGDrip(maxPriorityFeePerGas)} gdrip`,
            nonce,
        });
        super(cause.shortMessage, {
            cause,
            docsPath,
            metaMessages: [
                ...(cause.metaMessages ? [...cause.metaMessages, ' '] : []),
                'Raw Call Arguments:',
                prettyArgs,
            ].filter(Boolean),
        });
        this.cause = cause;
    }
}
export class ContractFunctionExecutionError extends BaseError {
    abi;
    args;
    cause;
    contractAddress;
    formattedArgs;
    functionName;
    sender;
    name = 'ContractFunctionExecutionError';
    constructor(cause, { abi, args, contractAddress, docsPath, functionName, sender, }) {
        const abiItem = getAbiItem({ abi, args, name: functionName });
        const formattedArgs = abiItem
            ? formatAbiItemWithArgs({
                abiItem,
                args,
                includeFunctionName: false,
                includeName: false,
            })
            : undefined;
        const functionWithParams = abiItem
            ? formatAbiItem(abiItem, { includeName: true })
            : undefined;
        const prettyArgs = prettyPrint({
            address: contractAddress && contractAddress,
            function: functionWithParams,
            args: formattedArgs &&
                formattedArgs !== '()' &&
                `${[...Array(functionName?.length ?? 0).keys()]
                    .map(() => ' ')
                    .join('')}${formattedArgs}`,
            sender,
        });
        super(cause.shortMessage ||
            `An unknown error occurred while executing the contract function "${functionName}".`, {
            cause,
            docsPath,
            metaMessages: [
                ...(cause.metaMessages ? [...cause.metaMessages, ' '] : []),
                'Contract Call:',
                prettyArgs,
            ].filter(Boolean),
        });
        this.abi = abi;
        this.args = args;
        this.cause = cause;
        this.contractAddress = contractAddress;
        this.functionName = functionName;
        this.sender = sender;
    }
}
export class ContractFunctionRevertedError extends BaseError {
    name = 'ContractFunctionRevertedError';
    data;
    reason;
    signature;
    constructor({ abi, data, functionName, message, }) {
        let cause;
        let decodedData = undefined;
        let metaMessages;
        let reason;
        if (data && data !== '0x') {
            try {
                decodedData = decodeErrorResult({ abi, data });
                const { abiItem, errorName, args: errorArgs } = decodedData;
                if (errorName === 'Error') {
                    reason = errorArgs[0];
                }
                else if (errorName === 'Panic') {
                    const [firstArg] = errorArgs;
                    reason = panicReasons[firstArg];
                }
                else {
                    const errorWithParams = abiItem
                        ? formatAbiItem(abiItem, { includeName: true })
                        : undefined;
                    const formattedArgs = abiItem && errorArgs
                        ? formatAbiItemWithArgs({
                            abiItem,
                            args: errorArgs,
                            includeFunctionName: false,
                            includeName: false,
                        })
                        : undefined;
                    metaMessages = [
                        errorWithParams ? `Error: ${errorWithParams}` : '',
                        formattedArgs && formattedArgs !== '()'
                            ? `       ${[...Array(errorName?.length ?? 0).keys()]
                                .map(() => ' ')
                                .join('')}${formattedArgs}`
                            : '',
                    ];
                }
            }
            catch (err) {
                cause = err;
            }
        }
        else if (message)
            reason = message;
        let signature;
        if (cause instanceof AbiErrorSignatureNotFoundError) {
            signature = cause.signature;
            metaMessages = [
                `Unable to decode signature "${signature}" as it was not found on the provided ABI.`,
                'Make sure you are using the correct ABI and that the error exists on it.',
                `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${signature}.`,
            ];
        }
        super((reason && reason !== 'execution reverted') || signature
            ? [
                `The contract function "${functionName}" reverted with the following ${signature ? 'signature' : 'reason'}:`,
                reason || signature,
            ].join('\n')
            : `The contract function "${functionName}" reverted.`, {
            cause,
            metaMessages,
        });
        this.data = decodedData;
        this.reason = reason;
        this.signature = signature;
    }
}
export class ContractFunctionZeroDataError extends BaseError {
    name = 'ContractFunctionZeroDataError';
    constructor({ functionName }) {
        super(`The contract function "${functionName}" returned no data ("0x").`, {
            metaMessages: [
                'This could be due to any of the following:',
                `  - The contract does not have the function "${functionName}",`,
                '  - The parameters passed to the contract function may be invalid, or',
                '  - The address is not a contract.',
            ],
        });
    }
}
export class CounterfactualDeploymentFailedError extends BaseError {
    name = 'CounterfactualDeploymentFailedError';
    constructor({ factory }) {
        super(`Deployment for counterfactual contract call failed${factory ? ` for factory "${factory}".` : ''}`, {
            metaMessages: [
                'Please ensure:',
                '- The `factory` is a valid contract deployment factory (ie. Create2 Factory, ERC-4337 Factory, etc).',
                '- The `factoryData` is a valid encoded function call for contract deployment function on the factory.',
            ],
        });
    }
}
export class RawContractError extends BaseError {
    code = 3;
    name = 'RawContractError';
    data;
    constructor({ data, message, }) {
        super(message || '');
        this.data = data;
    }
}
//# sourceMappingURL=contract.js.map