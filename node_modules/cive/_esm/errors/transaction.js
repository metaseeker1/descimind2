import { BaseError } from 'viem';
import { formatCFX } from '../utils/unit/formatCFX.js';
import { formatGDrip } from '../utils/unit/formatGDrip.js';
export function prettyPrint(args) {
    const entries = Object.entries(args)
        .map(([key, value]) => {
        if (value === undefined || value === false)
            return null;
        return [key, value];
    })
        .filter(Boolean);
    const maxLength = entries.reduce((acc, [key]) => Math.max(acc, key.length), 0);
    return entries
        .map(([key, value]) => `  ${`${key}:`.padEnd(maxLength + 1)}  ${value}`)
        .join('\n');
}
export class FeeConflictError extends BaseError {
    name = 'FeeConflictError';
    constructor() {
        super([
            'Cannot specify both a `gasPrice` and a `maxFeePerGas`/`maxPriorityFeePerGas`.',
            'Use `maxFeePerGas`/`maxPriorityFeePerGas` for EIP-1559 compatible networks, and `gasPrice` for others.',
        ].join('\n'));
    }
}
export class InvalidLegacyVError extends BaseError {
    name = 'InvalidLegacyVError';
    constructor({ v }) {
        super(`Invalid \`v\` value "${v}". Expected 27 or 28.`);
    }
}
export class InvalidSerializableTransactionError extends BaseError {
    name = 'InvalidSerializableTransactionError';
    constructor({ transaction }) {
        super('Cannot infer a transaction type from provided transaction.', {
            metaMessages: [
                'Provided Transaction:',
                '{',
                prettyPrint(transaction),
                '}',
                '',
                'To infer the type, either provide:',
                '- a `type` to the Transaction, or',
                '- an EIP-1559 Transaction with `maxFeePerGas`, or',
                '- an EIP-2930 Transaction with `gasPrice` & `accessList`, or',
                '- an EIP-4844 Transaction with `blobs`, `blobVersionedHashes`, `sidecars`, or',
                '- a Legacy Transaction with `gasPrice`',
            ],
        });
    }
}
export class InvalidSerializedTransactionTypeError extends BaseError {
    name = 'InvalidSerializedTransactionType';
    serializedType;
    constructor({ serializedType }) {
        super(`Serialized transaction type "${serializedType}" is invalid.`);
        this.serializedType = serializedType;
    }
}
export class InvalidSerializedTransactionError extends BaseError {
    name = 'InvalidSerializedTransactionError';
    serializedTransaction;
    type;
    constructor({ attributes, serializedTransaction, type, }) {
        const missing = Object.entries(attributes)
            .map(([key, value]) => (typeof value === 'undefined' ? key : undefined))
            .filter(Boolean);
        super(`Invalid serialized transaction of type "${type}" was provided.`, {
            metaMessages: [
                `Serialized Transaction: "${serializedTransaction}"`,
                missing.length > 0 ? `Missing Attributes: ${missing.join(', ')}` : '',
            ].filter(Boolean),
        });
        this.serializedTransaction = serializedTransaction;
        this.type = type;
    }
}
export class InvalidStorageKeySizeError extends BaseError {
    name = 'InvalidStorageKeySizeError';
    constructor({ storageKey }) {
        super(`Size for storage key "${storageKey}" is invalid. Expected 32 bytes. Got ${Math.floor((storageKey.length - 2) / 2)} bytes.`);
    }
}
export class TransactionExecutionError extends BaseError {
    cause;
    name = 'TransactionExecutionError';
    constructor(cause, { account, docsPath, chain, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, }) {
        const prettyArgs = prettyPrint({
            chain: chain && `${chain?.name} (id: ${chain?.id})`,
            from: account?.address,
            to,
            value: typeof value !== 'undefined' &&
                `${formatCFX(value)} ${chain?.nativeCurrency?.symbol || 'CFX'}`,
            data,
            gas,
            gasPrice: typeof gasPrice !== 'undefined' && `${formatGDrip(gasPrice)} gdrip`,
            maxFeePerGas: typeof maxFeePerGas !== 'undefined' &&
                `${formatGDrip(maxFeePerGas)} gdrip`,
            maxPriorityFeePerGas: typeof maxPriorityFeePerGas !== 'undefined' &&
                `${formatGDrip(maxPriorityFeePerGas)} gdrip`,
            nonce,
        });
        super(cause.shortMessage, {
            cause,
            docsPath,
            metaMessages: [
                ...(cause.metaMessages ? [...cause.metaMessages, ' '] : []),
                'Request Arguments:',
                prettyArgs,
            ].filter(Boolean),
        });
        this.cause = cause;
    }
}
export class TransactionNotFoundError extends BaseError {
    name = 'TransactionNotFoundError';
    constructor({ blockHash, blockNumber, epochTag, hash, index, }) {
        let identifier = 'Transaction';
        if (epochTag && index !== undefined)
            identifier = `Transaction at block time "${epochTag}" at index "${index}"`;
        if (blockHash && index !== undefined)
            identifier = `Transaction at block hash "${blockHash}" at index "${index}"`;
        if (blockNumber && index !== undefined)
            identifier = `Transaction at block number "${blockNumber}" at index "${index}"`;
        if (hash)
            identifier = `Transaction with hash "${hash}"`;
        super(`${identifier} could not be found.`);
    }
}
export class TransactionReceiptNotFoundError extends BaseError {
    name = 'TransactionReceiptNotFoundError';
    constructor({ hash }) {
        super(`Transaction receipt with hash "${hash}" could not be found. The Transaction may not be processed on a block yet.`);
    }
}
export class WaitForTransactionReceiptTimeoutError extends BaseError {
    name = 'WaitForTransactionReceiptTimeoutError';
    constructor({ hash }) {
        super(`Timed out while waiting for transaction with hash "${hash}" to be confirmed.`);
    }
}
//# sourceMappingURL=transaction.js.map