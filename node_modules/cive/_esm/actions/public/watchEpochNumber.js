import { hexToBigInt } from 'viem/utils';
import { observe } from '../../types/observe.js';
import { getAction } from '../../utils/getAction.js';
import { poll } from '../../utils/poll.js';
import { stringify } from '../../utils/stringify.js';
import { getEpochNumber, } from './getEpochNumber.js';
export function watchEpochNumber(client, { emitOnBegin = false, emitMissed = false, onEpochNumber, onError, poll: poll_, pollingInterval = client.pollingInterval, epochTag, }) {
    const enablePolling = (() => {
        if (typeof poll_ !== 'undefined')
            return poll_;
        if (client.transport.type === 'webSocket')
            return false;
        if (client.transport.type === 'fallback' &&
            client.transport.transports[0].config.type === 'webSocket')
            return false;
        return true;
    })();
    let prevEpochNumber;
    const pollEpochNumber = () => {
        const observerId = stringify([
            'watchEpochNumber',
            client.uid,
            emitOnBegin,
            emitMissed,
            pollingInterval,
        ]);
        return observe(observerId, { onEpochNumber, onError }, (emit) => poll(async () => {
            try {
                const epochNumber = await getAction(client, getEpochNumber, 'getEpochNumber')({ cacheTime: 0, epochTag });
                if (prevEpochNumber) {
                    // If the current epoch number is the same as the previous,
                    // we can skip.
                    if (epochNumber === prevEpochNumber)
                        return;
                    // If we have missed out on some previous epochs, and the
                    // `emitMissed` flag is truthy, let's emit those epochs.
                    if (epochNumber - prevEpochNumber > 1 && emitMissed) {
                        for (let i = prevEpochNumber + 1n; i < epochNumber; i++) {
                            emit.onEpochNumber(i, prevEpochNumber);
                            prevEpochNumber = i;
                        }
                    }
                }
                // If the next epoch number is greater than the previous,
                // it is not in the past, and we can emit the new epoch number.
                if (!prevEpochNumber || epochNumber > prevEpochNumber) {
                    emit.onEpochNumber(epochNumber, prevEpochNumber);
                    prevEpochNumber = epochNumber;
                }
            }
            catch (error) {
                emit.onError?.(error);
            }
        }, {
            emitOnBegin,
            interval: pollingInterval,
        }));
    };
    const subscribeEpochNumber = () => {
        const observerId = stringify([
            'watchEpochNumber',
            client.uid,
            emitOnBegin,
            emitMissed,
        ]);
        return observe(observerId, { onEpochNumber, onError }, (emit) => {
            let active = true;
            let unsubscribe = () => (active = false);
            (async () => {
                try {
                    const transport = (() => {
                        if (client.transport.type === 'fallback') {
                            const transport = client.transport.transports.find((transport) => transport.config.type === 'webSocket');
                            if (!transport)
                                return client.transport;
                            return transport.value;
                        }
                        return client.transport;
                    })();
                    const { unsubscribe: unsubscribe_ } = await transport.subscribe({
                        params: ['newHeads'],
                        onData(data) {
                            if (!active)
                                return;
                            const epochNumber = hexToBigInt(data.result?.number);
                            emit.onEpochNumber(epochNumber, prevEpochNumber);
                            prevEpochNumber = epochNumber;
                        },
                        onError(error) {
                            emit.onError?.(error);
                        },
                    });
                    unsubscribe = unsubscribe_;
                    if (!active)
                        unsubscribe();
                }
                catch (err) {
                    onError?.(err);
                }
            })();
            return () => unsubscribe();
        });
    };
    return enablePolling ? pollEpochNumber() : subscribeEpochNumber();
}
//# sourceMappingURL=watchEpochNumber.js.map