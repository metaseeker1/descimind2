import { extract } from 'viem/utils';
import { parseAccount, } from '../../accounts/index.js';
import { AccountNotFoundError } from '../../errors/account.js';
import { assertCurrentChain } from '../../utils/chain/assertCurrentChain.js';
import { getTransactionError, } from '../../utils/errors/getTransactionError.js';
import { formatTransactionRequest, } from '../../utils/formatters/transactionRequest.js';
import { getAction } from '../../utils/getAction.js';
import { assertRequest } from '../../utils/transaction/assertRequest.js';
import { getStatus } from '../public/getStatus.js';
import { defaultParameters, prepareTransactionRequest, } from './prepareTransactionRequest.js';
import { sendRawTransaction } from './sendRawTransaction.js';
export async function sendTransaction(client, parameters) {
    const { account: account_ = client.account, chain = client.chain, accessList, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, storageLimit, epochHeight, ...rest } = parameters;
    if (!account_) {
        throw new AccountNotFoundError({
            docsPath: '/docs/actions/wallet/sendTransaction',
        });
    }
    const account = parseAccount(account_);
    try {
        assertRequest(parameters);
        let chainId;
        if (chain !== null) {
            const nodeStatus = await getAction(client, getStatus, 'getStatus')({});
            chainId = nodeStatus.chainId;
            assertCurrentChain({
                currentChainId: chainId,
                chain,
            });
        }
        if (account.type === 'local') {
            // Prepare the request for signing (assign appropriate fees, etc.)
            const request = await getAction(client, prepareTransactionRequest, 'prepareTransactionRequest')({
                account,
                accessList,
                chain,
                chainId,
                data,
                gas,
                gasPrice,
                storageLimit,
                epochHeight,
                maxFeePerGas,
                maxPriorityFeePerGas,
                nonce,
                parameters: [...defaultParameters],
                to,
                value,
                ...rest,
            });
            const serializer = chain?.serializers?.transaction;
            const serializedTransaction = (await account.signTransaction(request, {
                serializer,
            }));
            return await getAction(client, sendRawTransaction, 'sendRawTransaction')({
                serializedTransaction,
            });
        }
        const chainFormat = client.chain?.formatters?.transactionRequest?.format;
        const format = chainFormat || formatTransactionRequest;
        const request = format({
            // Pick out extra data that might exist on the chain's transaction request type.
            ...extract(rest, { format: chainFormat }),
            accessList,
            data,
            from: account.address,
            gas,
            gasPrice,
            maxFeePerGas,
            maxPriorityFeePerGas,
            nonce,
            to,
            value,
        });
        return await client.request({
            method: 'cfx_sendTransaction',
            params: [request],
        }, { retryCount: 0 });
    }
    catch (err) {
        throw getTransactionError(err, {
            ...parameters,
            account,
            chain: parameters.chain || undefined,
        });
    }
}
//# sourceMappingURL=sendTransaction.js.map