import { encodePacked, isHex, keccak256, toBytes, toHex } from 'viem/utils';
import { create2FactoryAddress } from '../../constants/contract.js';
import { base32AddressToHex } from './base32AddressToHex.js';
import { hexAddressToBase32 } from './hexAddressToBase32.js';
export function getContractAddress(opts) {
    const bytecodeHash = (() => {
        if ('bytecodeHash' in opts) {
            if (isHex(opts.bytecodeHash))
                return opts.bytecodeHash;
            return toHex(opts.bytecodeHash);
        }
        return keccak256(encodePacked(['bytes'], [isHex(opts.bytecode) ? opts.bytecode : toHex(opts.bytecode)]), 'hex');
    })();
    const hexAddress = (() => {
        if (opts.opcode === 'CREATE2') {
            const create2Address = opts.create2FactoryAddress || create2FactoryAddress;
            if (isHex(create2Address))
                return create2Address;
            return base32AddressToHex({ address: create2Address });
        }
        return base32AddressToHex({ address: opts.from });
    })();
    const addressHash = keccak256(encodePacked(['bytes1', 'address', 'bytes32', 'bytes32'], [
        opts.opcode === 'CREATE2' ? '0xff' : '0x00',
        hexAddress,
        opts.opcode === 'CREATE2'
            ? toHex(opts.salt, { size: 32 })
            : toHex(toBytes(opts.nonce).reverse(), { size: 32 }),
        bytecodeHash,
    ]));
    return hexAddressToBase32({
        hexAddress: `0x8${addressHash.slice(-39)}`,
        networkId: opts.networkId,
        verbose: opts.verbose,
    });
}
//# sourceMappingURL=getContractAddress.js.map