"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.VERSION_BYTE = void 0;
exports.hexAddressToBase32 = hexAddressToBase32;
const viem_1 = require("viem");
const convertBit_js_1 = require("./convertBit.js");
const getAddressType_js_1 = require("./getAddressType.js");
const getNetworkIdPrefixByNetworkId_js_1 = require("./getNetworkIdPrefixByNetworkId.js");
const polyMod_js_1 = require("./polyMod.js");
exports.VERSION_BYTE = 0;
const ALPHABET = 'ABCDEFGHJKMNPRSTUVWXYZ0123456789';
function hexAddressToBase32({ hexAddress, networkId, verbose, }) {
    const hexBuffer = (0, viem_1.hexToBytes)(hexAddress);
    const addressType = (0, getAddressType_js_1.getAddressTypeByHexAddress)(hexBuffer);
    const netName = (0, getNetworkIdPrefixByNetworkId_js_1.getNetworkPrefixByNetworkId)(networkId).toUpperCase();
    const netName5Bits = (0, viem_1.stringToBytes)(netName).map((_byte) => _byte & 31);
    const payload5Bits = (0, convertBit_js_1.convertBit)(new Uint8Array([exports.VERSION_BYTE, ...hexBuffer]), 8, 5, true);
    const checksumBigInt = (0, polyMod_js_1.polyMod)(new Uint8Array([
        ...netName5Bits,
        0,
        ...payload5Bits,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
    ]));
    let checksumHex = (0, viem_1.toHex)(checksumBigInt);
    if (checksumHex.length < 12) {
        checksumHex = (0, viem_1.padHex)(checksumHex, { dir: 'left', size: 5 });
    }
    const checksumBytes = (0, viem_1.hexToBytes)(checksumHex);
    const checksum5Bits = (0, convertBit_js_1.convertBit)(checksumBytes, 8, 5, true);
    const payload = payload5Bits.map((_byte2) => ALPHABET[_byte2]).join('');
    const checksum = checksum5Bits.map((_byte3) => ALPHABET[_byte3]).join('');
    return (verbose
        ? `${netName}:TYPE.${addressType.toUpperCase()}:${payload}${checksum}`
        : `${netName}:${payload}${checksum}`.toLowerCase());
}
//# sourceMappingURL=hexAddressToBase32.js.map