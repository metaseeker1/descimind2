"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.decodeBase32Address = decodeBase32Address;
const viem_1 = require("viem");
const address_js_1 = require("../../errors/address.js");
const convertBit_js_1 = require("./convertBit.js");
const getAddressType_js_1 = require("./getAddressType.js");
const getNetworkIdByNetworkIdPrefix_js_1 = require("./getNetworkIdByNetworkIdPrefix.js");
const hexAddressToBase32_js_1 = require("./hexAddressToBase32.js");
const polyMod_js_1 = require("./polyMod.js");
const ALPHABET_MAP = {
    '0': 22,
    '1': 23,
    '2': 24,
    '3': 25,
    '4': 26,
    '5': 27,
    '6': 28,
    '7': 29,
    '8': 30,
    '9': 31,
    A: 0,
    B: 1,
    C: 2,
    D: 3,
    E: 4,
    F: 5,
    G: 6,
    H: 7,
    J: 8,
    K: 9,
    M: 10,
    N: 11,
    P: 12,
    R: 13,
    S: 14,
    T: 15,
    U: 16,
    V: 17,
    W: 18,
    X: 19,
    Y: 20,
    Z: 21,
};
function decodeBase32Address({ address, strict = true, }) {
    if (address !== address.toLowerCase() && address !== address.toUpperCase()) {
        throw new address_js_1.MixedCaseAddressError({ address });
    }
    const [, netName, shouldHaveType, payload, checksum] = address
        .toUpperCase()
        .match(/^([^:]+):(.+:)?(.{34})(.{8})$/) || ['', '', '', '', ''];
    const netName5Bits = (0, viem_1.stringToBytes)(netName).map((_byte) => _byte & 0b11111);
    const payload5Bits = Array.from(payload, (char) => ALPHABET_MAP[char]);
    const checksum5Bits = Array.from(checksum, (char) => ALPHABET_MAP[char]);
    const [version, ...addressBytes] = (0, convertBit_js_1.convertBit)(new Uint8Array([...payload5Bits]), 5, 8);
    if (version !== hexAddressToBase32_js_1.VERSION_BYTE) {
        throw new address_js_1.InvalidAddressVersionError({ address });
    }
    const byteAddress = new Uint8Array([...addressBytes]);
    const networkId = (0, getNetworkIdByNetworkIdPrefix_js_1.getNetworkIdByNetworkIdPrefix)(netName);
    const type = (0, getAddressType_js_1.getAddressTypeByHexAddress)(byteAddress);
    if (shouldHaveType && `type.${type}:` !== shouldHaveType.toLowerCase()) {
        throw new address_js_1.AddressTypeNotMatchError({ address });
    }
    if (strict) {
        const valid = (0, polyMod_js_1.polyMod)(new Uint8Array([...netName5Bits, 0, ...payload5Bits, ...checksum5Bits]));
        if (valid) {
            throw new address_js_1.InvalidAddressVersionError({ address });
        }
    }
    return {
        address: (0, viem_1.bytesToHex)(byteAddress),
        type: type,
        networkId: networkId,
    };
}
//# sourceMappingURL=decodeBase32Address.js.map