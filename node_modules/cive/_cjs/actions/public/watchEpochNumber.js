"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.watchEpochNumber = watchEpochNumber;
const utils_1 = require("viem/utils");
const observe_js_1 = require("../../types/observe.js");
const getAction_js_1 = require("../../utils/getAction.js");
const poll_js_1 = require("../../utils/poll.js");
const stringify_js_1 = require("../../utils/stringify.js");
const getEpochNumber_js_1 = require("./getEpochNumber.js");
function watchEpochNumber(client, { emitOnBegin = false, emitMissed = false, onEpochNumber, onError, poll: poll_, pollingInterval = client.pollingInterval, epochTag, }) {
    const enablePolling = (() => {
        if (typeof poll_ !== 'undefined')
            return poll_;
        if (client.transport.type === 'webSocket')
            return false;
        if (client.transport.type === 'fallback' &&
            client.transport.transports[0].config.type === 'webSocket')
            return false;
        return true;
    })();
    let prevEpochNumber;
    const pollEpochNumber = () => {
        const observerId = (0, stringify_js_1.stringify)([
            'watchEpochNumber',
            client.uid,
            emitOnBegin,
            emitMissed,
            pollingInterval,
        ]);
        return (0, observe_js_1.observe)(observerId, { onEpochNumber, onError }, (emit) => (0, poll_js_1.poll)(async () => {
            try {
                const epochNumber = await (0, getAction_js_1.getAction)(client, getEpochNumber_js_1.getEpochNumber, 'getEpochNumber')({ cacheTime: 0, epochTag });
                if (prevEpochNumber) {
                    if (epochNumber === prevEpochNumber)
                        return;
                    if (epochNumber - prevEpochNumber > 1 && emitMissed) {
                        for (let i = prevEpochNumber + 1n; i < epochNumber; i++) {
                            emit.onEpochNumber(i, prevEpochNumber);
                            prevEpochNumber = i;
                        }
                    }
                }
                if (!prevEpochNumber || epochNumber > prevEpochNumber) {
                    emit.onEpochNumber(epochNumber, prevEpochNumber);
                    prevEpochNumber = epochNumber;
                }
            }
            catch (error) {
                emit.onError?.(error);
            }
        }, {
            emitOnBegin,
            interval: pollingInterval,
        }));
    };
    const subscribeEpochNumber = () => {
        const observerId = (0, stringify_js_1.stringify)([
            'watchEpochNumber',
            client.uid,
            emitOnBegin,
            emitMissed,
        ]);
        return (0, observe_js_1.observe)(observerId, { onEpochNumber, onError }, (emit) => {
            let active = true;
            let unsubscribe = () => (active = false);
            (async () => {
                try {
                    const transport = (() => {
                        if (client.transport.type === 'fallback') {
                            const transport = client.transport.transports.find((transport) => transport.config.type === 'webSocket');
                            if (!transport)
                                return client.transport;
                            return transport.value;
                        }
                        return client.transport;
                    })();
                    const { unsubscribe: unsubscribe_ } = await transport.subscribe({
                        params: ['newHeads'],
                        onData(data) {
                            if (!active)
                                return;
                            const epochNumber = (0, utils_1.hexToBigInt)(data.result?.number);
                            emit.onEpochNumber(epochNumber, prevEpochNumber);
                            prevEpochNumber = epochNumber;
                        },
                        onError(error) {
                            emit.onError?.(error);
                        },
                    });
                    unsubscribe = unsubscribe_;
                    if (!active)
                        unsubscribe();
                }
                catch (err) {
                    onError?.(err);
                }
            })();
            return () => unsubscribe();
        });
    };
    return enablePolling ? pollEpochNumber() : subscribeEpochNumber();
}
//# sourceMappingURL=watchEpochNumber.js.map